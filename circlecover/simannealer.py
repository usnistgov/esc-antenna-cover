from simanneal import Annealer
from shapely.geometry import Polygon
from shapely.geometry import Point
import antennacover
import excessarea
import math
import pdb
import random
import copy


class SimAnneal(Annealer):

    def covers(self,cover_polygons):
        """ 

        boolean to determine whether the collection of points is covered by the given set of lobes. 
        If this returns True then a valid cover has been found. We allow a small amount of 
        slop in the cover (.005%) to give the algorithm a chance to do better.

        """
        # For each point in our grid, check to see if the point is covered by at least one lobe
        union = cover_polygons[0]
        for i in range(1,len(cover_polygons)):
            union = union.union(cover_polygons[i])
        area = self.bounding_polygon.difference(union).area
        ratio = area/self.bounding_polygon.area
        return  ratio <= self.max_ratio


    def energy(self):
        """ 
        The energy function for the simulated annealing. 
        This is called back by the simanneal function. 
        Our energy function is the area of the convex hull enclosed
        by the antenna lobes. 
        """
        cover_polygons = self.cover_polygons
        union = cover_polygons[0]
        for i in range(1,len(cover_polygons)):
            union = union.union(cover_polygons[i])
        return union.area


    def move(self):
        """
        The move function called back by the simanneal parent class.
        """
        while True:
            # pick an intersecting polygon index
            #pindex = random.randint(0, len(self.intersecting_polygons)-1)

            # pindex = self.index_count % len(self.intersecting_polygons)
            # index = self.intersecting_polygons[pindex]

            # index = self.index_count % len(self.cover_polygons)
            index = random.randint(0, len(self.cover_polygons)-1)
            sign = -1 if random.randint(0,1) == 0 else 1
            # Peturb the solution by one degree.
            delta_angle = 1*math.pi/180*sign
            new_angle = delta_angle + self.state[index]
            new_angles = copy.copy(self.state)
            new_angles[index] = new_angle
            # Generate the cover lobes.
            cover_polygons = excessarea.generate_antenna_cover_polygons(self.indexes,new_angles,self.centers,self.detection_coverage)
            if (self.covers(cover_polygons)):
                # if the cover is good then keep the new angles
                self.state = new_angles
                # keep the cover polygons.
                self.cover_polygons = cover_polygons
                break
            self.index_count = self.index_count + 1


    def get_result(self):     
        """ 
        Prune unecessary antenna lobes and retrieve the result.
        """
        cover_polygons = excessarea.generate_antenna_cover_polygons(self.indexes,self.best_state,self.centers,self.detection_coverage)
        # Now remove a polygon at a time and see if the cover criterion is met.
        indexes_to_remove = []
        # loosen up our cover criterion a little
        for i in range(0,len(cover_polygons)):
            newcover = [cover_polygons[k] for k in range(0,len(cover_polygons)) if k != i and k not in indexes_to_remove]
            if self.covers(newcover):
                indexes_to_remove.append(i)
            
        print ("indexes_to_remove " + str(indexes_to_remove))
        centers = [self.centers[i] for i in range(0,len(self.centers)) if i not in indexes_to_remove]
        indexes = [self.indexes[i] for i in range(0,len(self.indexes)) if  i not in indexes_to_remove]
        angles =  [self.best_state[i] for i in range(0,len(self.state)) if i not in indexes_to_remove]
        return zip(centers,indexes,angles)


    def __init__(self,interference_contour, possible_centers, detection_coverage_file,cover,steps = 0,tol=.005):
        """
        Parameters:
            interference_contour : an ordered set of points that defines the interference contour. No loops are allowed. The 
                                points should be specified in increasing Z-order see https://en.wikipedia.org/wiki/Z-order_curve
            possible_centers : An ordered set of points on the coastline that follows the intereference contour with the same restrictions
                                as the interference contour. In general, because the coastline does not loop back on itself, 
                                these constraints can be naturally satisifed by just sampling the coastline.
            detection_coverage_file: A text file with the detection coverage of the antenna. 
                                See https://github.com/usnistgov/circle-cover/raw/master/figures/DetectionCoverage_90deg.png for example. 
            cover : The cover generated by the antenna_cover_greedy algorithm

        """
        self.interference_contour = interference_contour
        self.possible_centers = possible_centers
        self.centers = [c[0] for c in cover   ]
        self.indexes = [c[1] for c in cover   ]
        self.state =  [c[2] for c in cover  ]
        # load the detection coverage file.
        self.detection_coverage = antennacover.read_detection_coverage(detection_coverage_file)
        # the polygons representing the antenna shapes (rotated and translated)
        self.cover_polygons = excessarea.generate_antenna_cover_polygons(self.indexes,self.state,self.centers,self.detection_coverage)
        # The bounding polygon consisting of the shore and the interference contour.
        self.bounding_polygon = excessarea.generate_bounding_polygon(possible_centers,interference_contour)
        # Take the union of these shapes
        union = self.cover_polygons[0]
        for i in range(1,len(self.cover_polygons)):
            union = union.union(self.cover_polygons[i])
        # The uncovered area.
        area = self.bounding_polygon.difference(union).area
        # max_ratio is the max allowable uncovered area as a fraction.
        self.max_ratio = max(area/self.bounding_polygon.area,tol)
        # The counter that allows us to step through the array of polygons repeatedly
        self.index_count = 0
        # The number of moves allowed.
        if steps == 0:
            self.steps = len(self.cover_polygons) * 50
        else:
            self.steps = steps

